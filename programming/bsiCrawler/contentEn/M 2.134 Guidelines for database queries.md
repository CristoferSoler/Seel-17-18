#M 2.134 Guidelines for database queries
Responsible for initiation: IT security officer, IT manager

Responsible for implementation: Developer

The relational database language SQL (Structured Query Language) is an internationally standardized language for relational database systems (DBS) that has gained widespread use and is implemented in most database management systems (DBMS). The language scope is defined in cyclically revised standards (ANSISQL-92, ANSI SQL-99, ANSI SQL-2003). SQL can be used to formulate modifications to the data (UPDATE, INSERT, DELETE) as well as the database objects (CREATE, ALTER, DROP) as well as to query information (SELECT).

Guidelines for efficient, maintainable and traceable programming of database queries have to be created and implemented within the programming framework. The following principles should be described in this policy:

* Queries to the database should not be made directly on tables, but via views and procedures. On the one hand, this can better guarantee the protection of the data (see M 2.129 Access control of a database). On the other hand, it can be ensured that the necessary information is provided to the users in appropriate formatting and quantity. In addition, these views and procedures can be swapped out to a separate DB, and users and applications can only access these paged DBs. The data in the tables are then accessible only to a special group of users (administrators, etc.) via the procedures and views of the exported DB.
* SQL queries should be formulated exactly and explicitly based on the DB model. All requested fields should be specified explicitly and the * -operator should be avoided. This ensures that the data is made available in the expected order and that only the data that is actually required is selected. Example: A DB model contains a table with the fields item number, item description, Purpose and net price. In the course of an extension of the application, an additional field with the name order number is inserted after the purpose of use. However, for reasons of optimal memory utilization, the DBMS does not insert the new field there, but instead the second digit after the article number. Because the data is queried using a SELECT * statement, the database returns the information in a different order than the application expects. This leads to problems in the application, the cause of which is initially not recognizable.
* In the case of restrictive database requests (WHERE clause), the order of the specified selection conditions is of great importance for the execution speed. The WHERE clause should be formulated to first specify the condition that will select the smallest possible result set in the shortest possible time. Indexed fields should be accessed first, then non-indexed fields, where checks for digits are faster than checks on texts. The same applies analogously for database queries that are formulated across several tables (so-called joins). Many DBMS already optimize database requests on their own. Often, several optimization strategies are even offered for selection, which can be selected via various parameters. Some DBMSs offer the possibility to examine the processing of database requests (eg in Oracle with EXPLAIN or for Ingres with SETOEP). Furthermore, there is the possibility to explicitly define their processing via the so-called HINTS in the database query and thus in principle to switch off the optimizer. However, this option should be used with care.
* Which optimizer supports the DBMS and their advantages and disadvantages are usually documented in the manuals of the DBMS. The use of alternative optimizers within a DBMS should be discussed with the administrator.
* In the case of joins, it should also be noted that the assignment of fields to the tables is unique.
* Example: The ID field exists in both tables and must therefore be explicitly specified with the associated table name during the database request. Otherwise the uniqueness of the selection is no longer guaranteed and the database request is aborted with a corresponding error message. All other fields in this case must be clearly assigned to the respective tables. Explicit specification of the associated table name for each field is not required by SQL. Nevertheless, the individual fields should be uniquely assigned to the table, as in the example above for the Price and Name fields of the Table TabB. Adding a field Label for TabA would not cause any problems in the above example. However, this would not be the case if the SQL statement did not explicitly include the mapping of the fields to the tables. It would no longer be clear whether the field Name of TabA or TabB should be selected, since both tables have a field with this name after the modification of TabA. The SQL statement was aborted with an error message.
* All database transactions should be explicitly confirmed with a COMMIT. If the DBMS supports an automatic COMMIT, this should not be activated, as otherwise there may be unwanted inconsistencies in the database. Example: Several individual modifications are logically combined, but will be executed after execution each individual modification automatically confirmed by a COMMIT. If there is an uncontrolled abort of the transaction and, as a result, a rollback, the operations performed first are already confirmed and remain in the database, while the rest could not yet be performed.
* To avoid lock conflicts or even deadlocks, a blocking strategy must be defined for each functional database (for example, hierarchical locking or explicit locking of all tables at the beginning of the transaction).
* Application developers should check the error status after each SQL statement so that the application can respond to errors as early as possible.
* Permissions on system-specific commands that can be used, for example, to turn off logging or to change the locking procedure should be revoked for users and restricted to administrators.
* When developing applications, all database accesses should be grouped together in one module or part of the program code, otherwise the entire program code of the application system would have to be used to verify the above principles. As a result, the maintenance and care of the application system, for. For example, changes to the data model.




